

https://www.youtube.com/watch?v=BpPEoZW5IiY&t=10793s








###  lifetime

1. Another kind of generic ensuring that references are valid as long as needed
2. Every reference has a lifetime, which is the scope for which that reference is valid
3. Most of time implicit and inferred, don't need to worry
4. Sometimes lifetime annotations are needed, if the compiler can't infer it
5. Lifetime annotations is a concept which most other programming languages don't have

Main aim of lifetime is to prevent dangling references(also called dangling pointers)

The compiler uses lifetime to ensure all borrows are valid. 

#
fn main() {

  main scope

  {
      sub scope
  }

  {
      sub scope
  }


  {
    // reference 用后即弃？
    let x = 5;             //   ------ 'b
    let r = &x;            //   ---'a
    println!("r: {}", r)   //   ---'a
  }                        //   ------ 'b

  // rust compiler 要确保reference死在实体前面。

}

// lifetime标注符要和&紧紧连接，因为是reference的生命周期
// One input reference with lifetime 'a which must live at least as long as the function.
// reference要活得比function长
fn print_one<'a>(x: &'a i32) {
  println!("`print one`: x is {}", x);
}

// Mutable references are possible with lifetime as well.
fn add_one<'a>(x: &'a mut i32){
  *x += 1;
}

// Multiple elements with different lifetimes . In this case, it would be fine for both to have the same lifetime 'a, 
// but in more complex cases, different lifetimes may be required.
fn print_multi<'a, 'b>(x: &'a i32, y:&'b i32) {
  println!("`print_multi`: x is {}, y is {}", x, y);
}

// Returning references thar have been passed in is acceptable.  
// However, the correct lifetime must be returned.
fn pass_x<'a, 'b>(x: &'a i32, _: &'b i32) -> &'a i32 { 
  x 
}

fn main(){
    let x = 7;
    let y = 9;
    print_one(&x);
    print_multi(&x, &y);

    let z = pass_x(&x, &y);
    print_one(z);


}




#

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let x: &str = "long";
    let y: &str = "longer";
}


#
// 'a must live longer than the function.
// function的本质是一个局部scope
fn invalid_output<'a>() -> &'a String {
    &String::from("foo")

}

# `print_refs` takes two references to `i32` which have different lifetimes `'a` and `'b` . These two lifetimes must both be at 
least as long as the function `print_refs`.
// 函数也可以是借用者，不仅仅用=借用
fn print_refs<'a, 'b>(x : &'a i32 , y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}


