
1、在函数定义中调用一个“不确定”的函数

//调用一个不确定的函数，而且这个函数是任意的
fn run<F>(f: F) where F: Fn() {
  f();
}

//调用一个不确定的函数处理“3”，并返回处理结果，但是对提供的函数的参数和返回值有特定要求
fn add3<F>(f: F) where F: Fn(i32) -> i32 {
  f(3)
}

2、struct中泛型参数的bound为函数类
struct A<F: Fn(i32) -> i32 > {
  f:F
}



